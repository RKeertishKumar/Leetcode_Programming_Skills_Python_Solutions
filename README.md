# Leetcode Programming Skills Python Solutions

The repo has a well-commented markdown file for the programming skills section of Leetcode problems for quick review.

## Question 1

**1768. Merge Strings Alternately**

You are given two strings `word1` and `word2`. Merge the strings by adding letters in alternating order, starting with `word1`. If a string is longer than the other, append the additional letters onto the end of the merged string.

Return the merged string.

### Example 1

**Input:** `word1 = "abc"`, `word2 = "pqr"`  
**Output:** `"apbqcr"`  
**Explanation:** The merged string will be merged as so:
```
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r
```

### Solution

```python
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        # Let's have an empty string to store the new string
        new_string = ""

        # Find the minimum length of both the strings so we know until which index the loop has to run so that we don't get an out of index error
        minlen = min(len(word1), len(word2))

        # Let's go through both the strings and add the character to the new array
        for i in range(minlen):
            new_string += word1[i]
            new_string += word2[i]

        # Use the slice function to add the remaining characters. If there are no remaining characters, it doesn't add anything
        # Notice we start the slicing form the minimum length, thus only the word with the greater length of the variable will be added.
        new_string += word1[minlen:]
        new_string += word2[minlen:]

        return new_string
```
## Question 2

**389. Find the Difference**

You are given two strings s and t.String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t.

### Example 1:

**Input:** s = "abcd", t = "abcde"
**Output:** "e"
**Explanation:** 'e' is the letter that was added.

```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        # We will use low level ASCII logic to quickly calculate this. Hence, assign value 0 to an empty string

        ans = 0
        # We iterate through the string until the minimum value of string

        for i in range(len(s)):

            # Add the ASCII value of each character from the string with the extra character. We use ord function which returns the ASCII value of the character passed as parameter
            ans += ord(t[i])
                
            # Minus the ASCII value of character from the other string so that the difference left eventually would be the numerical value of the character we seek.
            ans -= ord(s[i])
            
            # Increment value of i to iterate through the loop
            i += 1

        # Since, we have one character remaining which isn't added in the first iteration, we add that here.
        ans += ord(t[len(s)])

        # chr() function returns the character when the ASCII value is passed as the parameter
        return chr(ans)
```

## Question 3

**28. Find the Index of the First Occurrence in a String**

Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

**Example 1:**

**Input:** haystack = "sadbutsad", needle = "sad"
**Output:** 0
**Explanation:** "sad" occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        return haystack.find(needle)
```

Other approaches to explain in case of interview:
We could make use of a loop and slice function to compare the sliced haystack string with the needle.

## Question 4

**242. Valid Anagram**

Given two strings s and t, return true if t is an anagram of s, and false otherwise.

**Example 1:**

**Input:** s = "anagram", t = "nagaram"
**Output:** true

```python
from collections import Counter

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)
```
Other approches:
Sort the strings and compare the sorted string to check if they are an anagram or not.

## Question 5

**459. Repeated Substring Pattern**

Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.

**Example 1:**

**Input:** s = "abab"
**Output:** true
**Explanation:** It is the substring "ab" twice.


```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        return s in s[1:] + s[:-1]
```

## Question 6

**283. Move Zeroes**

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

Example 1:

Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        zero = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[i], nums[zero] = nums[zero], nums[i]
                zero += 1
            i += 1
```

## Question 7

**66. Plus One**

You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

Increment the large integer by one and return the resulting array of digits.
Example 1:

Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].

Convert the list to a number, add a digit and return it as a list.

```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        string = ''.join(str(n) for n in digits)
        num = int(string)
        num += 1
        string_num = str(num)
        new_list = []
        for c in string_num:
            new_list.append(int(c))
        
        return new_list
```

Simple logic with iterating the loop from the end and add a digit to check if the value goes above 10 and if it does jump to add value to next digit.

```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        
        for i in range(len(digits) -1, -1, -1):
            if digits[i] == 9:
                digits[i] = 0
            else:
                digits[i] += 1
                return digits
            
        return [1] + digits
```

## Question 8

**1822. Sign of the Product of an Array**

Implement a function signFunc(x) that returns:

1 if x is positive.
-1 if x is negative.
0 if x is equal to 0.
You are given an integer array nums. Let product be the product of all values in the array nums.

Return signFunc(product).
Example 1:

Input: nums = [-1,-2,-3,-4,3,2,1]
Output: 1
Explanation: The product of all values in the array is 144, and signFunc(144) = 1

```python
class Solution:
    def arraySign(self, nums: List[int]) -> int:
        if 0 in nums:
            return 0
        p = 0
        n = 0
        for i in nums:
            if i < 0:
                n += 1
        
        if n%2 == 0:
            return 1
        else:
            return -1
```

## Question 9

**1502. Can Make Arithmetic Progression From Sequence**

A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.

Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.

Example 1:

Input: arr = [3,5,1]
Output: true
Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.

```python
class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr.sort()
        diff = arr[1] - arr[0]

        for i in range(1, len(arr) - 1):
            if diff != arr[i + 1] - arr[i]:
                return False
            else:
                i += 1
            
        return True
```

## Question 10

**896. Monotonic Array**

An array is monotonic if it is either monotone increasing or monotone decreasing.
An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].
Given an integer array nums, return true if the given array is monotonic, or false otherwise.

Example 1:

Input: nums = [1,2,2,3]
Output: true

A simple one pass code that checks if there is a greater than or not scenario, stores the result in boolean to compute at the end for both conditions

```python
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        is_increasing = True
        is_decreasing = True
        for i in range(0, len(nums) - 1):
            if nums[i] > nums[i + 1]:
                is_increasing = False
            if nums[i] < nums[i + 1]:
                is_decreasing = False

        return is_increasing or is_decreasing
```

Another simple method to sort the list and compare it for ascending order list. Then reverse the sorted list to compare with the decreasing list scenario

```python
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        sorted_nums = sorted(nums)
        if nums == sorted_nums:
            return True
        elif nums == list(reversed(sorted_nums)):
            return True
        else:
            return False
```
